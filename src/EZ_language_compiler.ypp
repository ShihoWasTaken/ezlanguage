%{

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <list>
#include <string>
#include <vector>

#include "../src/global.h"	 // we start from ../obj because it's important
#include "../src/main.cpp"	 // we start from ../obj because it's important
#include "../src/modules/Node.h"
#include "../src/modules/Variable.h"
#include "../src/modules/Function.h"
#include "../src/modules/ScopeHashTable.h"
#include "../src/modules/DeclarationProcedure.h"
#include "../src/modules/DeclarationFunction.h"
#include "../src/modules/Declaration.h"


//#include "global.h"

#define YYERROR_VERBOSE
#define USE(VALUE) /*empty*/

extern FILE* yyin;
using namespace std;

 int yyparse (void);
 extern "C" int yylex();
 extern "C" void yyerror(const std::string&);
 extern "C" void yyprint(const std::string&);
extern int yylineno;

extern ScopeHashTable symbolTable;
%}


%token<numerical_value>	NUM_INTEGER			// ENTIER
%token<reel_value>	NUM_REAL			// REEL
%token<texte>	NAME RETOUR	STRING			// NOM
%token	COMMA  DEGRE POURCENT DIESE POINT QUOTE		// Caractères
%token<texte> TYPE_INTEGER TYPE_REAL TYPE_STRING TYPE_BOOLEAN			// variables typeVar
%token  EGAL NE LT LE GT GE PLUS MINUS MULT DIVISE
%token	LEFT_PARENTHESIS RIGHT_PARENTHESIS LEFT_ACCOLADE RIGHT_ACCOLADE LEFT_BRACKET RIGHT_BRACKET FIN BACK_LINE	// Special Characters
%token<texte> CONST  LOCAL  GLOBAL  IS  ARE 		      		         // variables declaration
%token IF DO ELSE   						 // if else
%token WHEN CASE  DEFAULT ENDWHEN				 // switch case ...
%token WHILE ENDWHILE							 // while .. do ..
%token REPEAT UNTIL ENDREPEAT 						 // do .. while ...
%token FOR IN STEP ENDFOR
%token END
%token FUNCTION PROCEDURE RETURN ENDFUNCTION ENDPROCEDURE	 	 // functions
%token PRINT
%token END_OF_FILE

%left PLUS MINUS EGAL
%left NE LT LE GT GE MULT DIVISE AND OR XOR NOT MOD POW ABS		// Operators

%type<texte> typeVar
%type<arbre> expression designator single_expression  statement_sequence function_call
%type<arbre> next_line  function procedure  string
%type<arbre> ROOT declarations_list declaration_variables declaration_methods variable_with_scope variable_without_scope
%type<vecString> liste_argument

%start ROOT
%%

ROOT:
  next_line_null declarations_list  statement_sequence END_OF_FILE
      {
        Node *p_decl = $2;
        p_decl->setRightSon($3);
        Node *racine = new Node(NULL,p_decl);


        cout << racine->translate() << endl;
        return 0;
      }
;

next_line_null: /* can be empty */
| next_line {}

next_line:  // one or several new line
  BACK_LINE {}
| next_line BACK_LINE {}
;

declarations_list:
  /* no declaration */
  declaration_variables  declaration_methods  { $$ = new Node($1,$2);}

;

declaration_methods:
 { $$ = new Node();}
| declaration_methods function next_line { $$ = new Node($1,$2);}
| declaration_methods procedure next_line { $$ = new Node($1,$2);}
;

declaration_variables:
 { $$ = new Node();}
| declaration_variables   variable_with_scope {$$ = new Node($1,$2);}
| declaration_variables   variable_without_scope {$$ = new Node($1,$2);}
;

variable_without_scope:
     NAME IS typeVar next_line { Variable v($1,$3); symbolTable.addElement(v); $$ = new Declaration($1,$3,"",false);}
|    NAME noms ARE typeVar next_line { $$ = new Declaration(); }
;

variable_with_scope:
    portee NAME IS typeVar next_line { Variable v($2,$4); symbolTable.addElement(v); $$ = new Declaration($2,$4,$1,false);  }
|   portee NAME noms ARE typeVar next_line { $$ = new Declaration();  }
;

function:
FUNCTION NAME LEFT_PARENTHESIS liste_argument { symbolTable.incScope(); }  RIGHT_PARENTHESIS RETURN typeVar next_line statement_sequence RETURN expression next_line END next_endfunction
		{
			DeclarationFunction *f = new DeclarationFunction($2,$4,$8,$10,"blabla");
			$$ = f;
			//$$ = new Node();
			symbolTable.decScope();
		}
;

procedure:
PROCEDURE NAME LEFT_PARENTHESIS liste_argument { symbolTable.incScope(); } RIGHT_PARENTHESIS next_line statement_sequence  END next_endprocedure 
		{
			DeclarationProcedure *f = new DeclarationProcedure($2,$4,$8);
			$$ = f;
			//$$ = new Node();
			symbolTable.decScope();
		}
;

next_endprocedure:
/* empty */
| PROCEDURE {}
;

next_endfunction:
/* empty */
| FUNCTION {}
;

next_endif:
/* empty */
| IF {}
;

next_endwhen:
/*empty */
| WHEN  {}
;

next_endcase:
/* empty*/
| CASE {}
;

next_endwhile:
/* empty */
|  WHILE {}
;

next_endrepeat:
/* empty */
| REPEAT {}
;


statement_sequence:
 /*empty */  { $$ = new Node();}
| statement_sequence statement{ }
;

liste_argument:
 	 { vector<Variable> v; $$ = v;}
 | NAME IS typeVar { vector<Variable> v; v.push_back(Variable($1,$3)); $$ = v;}
 | NAME IS typeVar COMMA liste_argument { $5.push_back(Variable($1,$3));
 										$$ = $5; }
;

statement:
  next_line
| variable_with_scope {} // variables declaration
| variable_without_scope {} // variables declaration
| affectation {}
| printing {}
| IF expression DO statement_sequence ELSE statement_sequence END next_endif { }
| IF expression DO statement_sequence END next_endif {  }
| WHEN expression IS next_line whenbody whendefault END next_endwhen {  }
| WHILE expression DO  statement_sequence END next_endwhile { }
| REPEAT statement_sequence UNTIL next_line expression next_line END next_endrepeat{ }
| for {}
;

affectation:
  NAME EGAL expression { yyprint("affectation : "+$1+" = expression"); }
| NAME PLUS PLUS {  }
| NAME MINUS MINUS { }
| PLUS PLUS NAME  { }
| MINUS MINUS NAME  { }
;

printing :
 PRINT string { }
|PRINT string noms {  } 
|PRINT expression {}
;

for :
  FOR NAME IN NUM_INTEGER POINT POINT nbrOrName STEP nbrOrName next_line DO  statement_sequence ENDFOR { }
| FOR NAME IN NUM_INTEGER POINT POINT function_call STEP expression next_line DO  statement_sequence ENDFOR { }
;

function_call : 
NAME POINT NAME LEFT_PARENTHESIS RIGHT_PARENTHESIS {}
;

nbrOrName:
  NUM_INTEGER  {}
| NUM_REAL
| designator {}
;

portee: 
 LOCAL { $$ = $1;}
| GLOBAL { $$ = $1;}
;

typeVar:
  TYPE_INTEGER { $$ = "int";}
| TYPE_REAL   { $$ = "real";} 
| TYPE_STRING  { $$ = "string";} 
| TYPE_BOOLEAN  { $$ = "bool";}
;

noms:
  COMMA NAME noms {}
| COMMA NAME {}
;

whenbody: /* whenbody can't be empty */
  whenbody CASE expression statement_sequence END next_endcase next_line{}
| CASE  expression next_line statement_sequence next_line END next_endcase next_line {}
;

whendefault: /* May not be specified */
| DEFAULT statement_sequence END next_endcase next_line{}
;

string :
 STRING  { $$ = $1; }
;

expression:
 expression EGAL EGAL expression { $$ = new Node(); }
| expression NE expression {$$ = new Node();}
| expression LT expression { $$ = new Node(); }
| expression LE expression { $$ = new Node();}
| expression GT expression {$$ = new Node();}
| expression GE expression { $$ = new Node();}
| expression PLUS expression {$$ = new Node();}
| expression MINUS expression { $$ = new Node();}
| expression MULT expression {$$ = new Node();}
| expression DIVISE expression {$$ = new Node(); }
| expression AND AND expression { $$ = new Node();}
| expression OR OR expression {$$ = new Node(); }
| designator {$$ = new Node();}
| NUM_REAL { $$ = new Node(); } //real
| NUM_INTEGER {$$ = new Node(); }  // integer
//| single_expression {yyprint("single_expression");  $$ = new Node();}

//| single_expression XOR single_expression { $$ = new Node();}
//| NOT single_expression { $$ = new Node();}
//| single_expression MOD single_expression { $$ = new Node();}
//| single_expression POW single_expression { $$ = new Node();}
//| ABS single_expression {$$ = new Node(); }
| LEFT_PARENTHESIS expression RIGHT_PARENTHESIS {$$ = new Node();}
| function_call {$$ = new Node();}
//| PLUS single_expression { $$ = new Node(); }
;

designator:
  NAME { $$=$1; }

;

%%

void yyerror(const std::string& mess){
    std::cout << "Erreur trouvée à la ligne " << yylineno << " :  "<<mess  << std::endl;
}

void yyprint(const std::string& mess){
    std::cout << "[l" << yylineno << "] "<<mess  << std::endl;
}
