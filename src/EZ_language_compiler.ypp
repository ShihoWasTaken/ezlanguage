%{

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <list>

#include "../src/global.h"	 // we start from ../obj because it's important
#include "../src/main.cpp"	 // we start from ../obj because it's important
#include "../src/modules/Node.h"
#include "../src/modules/variable.h"
//#include "global.h"

#define YYERROR_VERBOSE
#define USE(VALUE) /*empty*/

extern FILE* yyin;
using namespace std;

 int yyparse (void);
 extern "C" int yylex();
 extern "C" void yyerror(const std::string&);
extern int yylineno;

%}


%token<numerical_value>	NUM_INTEGER			// ENTIER
%token<real_value>	NUM_REAL				// REEL
%token<texte>	NAME RETOUR		STRING			// NOM
%token	COMMA  DEGRE POURCENT DIESE POINT QUOTE	// Caractères
%token TYPE_INTEGER TYPE_REAL TYPE_STRING TYPE_BOOLEAN			// Type des variables
%token  EGAL NE LT LE GT GE PLUS MINUS MULT DIVISE
%token	LEFT_PARENTHESIS RIGHT_PARENTHESIS LEFT_ACCOLADE RIGHT_ACCOLADE LEFT_BRACKET RIGHT_BRACKET FIN BACK_LINE	// Special Characters
%token CONST  LOCAL  GLOBAL  IS  ARE 		      		      // variables declaration
%token IF DO ELSE  ENDIF 						 // if else 
%token WHEN CASE ENDCASE DEFAULT ENDWHEN				 // switch case ...
%token WHILE ENDWHILE							 // while .. do ..
%token REPEAT UNTIL ENDREPEAT 						 // do .. while ...
%token FOR IN STEP ENDFOR
%token FUNCTION PROCEDURE RETURN ENDFUNCTION ENDPROCEDURE	 // functions
%token PRINT							         // loop for
%token END_OF_FILE

%left PLUS MINUS EGAL
%left NE LT LE GT GE MULT DIVISE

%type<arbre> expression designator expr2 expr3 expr4  statement_sequence 
%type<arbre> next_line  function procedure  string
%type<arbre> ROOT declarations_list declaration_variables declaration_methods variable_with_scope variable_without_scope

%start ROOT
%%


ROOT:
  next_line_null declarations_list  statement_sequence END_OF_FILE
      {
        Node *p_decl = $2;
        p_decl->setRightSon($3);
        Node *n = new Node(NULL,p_decl);


        return 0;
      }
;

next_line_null: /* can be empty */
| next_line {}

next_line:  // one or several new line
  BACK_LINE {}
| next_line BACK_LINE {}
;

declarations_list:
  /* no declaration */
  declaration_variables  declaration_methods  { $$ = new Node($1,$2);}

;

declaration_methods:
| declaration_methods function next_line { $$ = new Node($1,$2);}  
| declaration_methods procedure next_line { $$ = new Node($1,$2);}
;

declaration_variables:
| declaration_variables   variable_with_scope {$$ = new Node($1,$2);}
| declaration_variables   variable_without_scope {$$ = new Node($1,$2);}
;

variable_with_scope:
     NAME IS type next_line { $$ = new variable();}
|    NAME noms ARE type next_line { $$ = new variable(); }
;

variable_without_scope:
    portee NAME IS type next_line { $$ = new variable();  }
|   portee NAME noms ARE type next_line { $$ = new variable();  }
;

function:
FUNCTION NAME LEFT_PARENTHESIS liste_argument RIGHT_PARENTHESIS RETURN type next_line statement_sequence RETURN expression next_line ENDFUNCTION { printf( "declaration d'une fonction \n");}
;

procedure:
PROCEDURE NAME LEFT_PARENTHESIS liste_argument RIGHT_PARENTHESIS next_line statement_sequence  ENDPROCEDURE {cout << "Declaration de la procedure "  << endl;}
;

statement_sequence:
  { /*printf("  statement \n");*/ }
| statement_sequence statement{ }
;

liste_argument:
 // No argument
 | NAME IS type { }
 | NAME IS type COMMA liste_argument { }
;

statement:
  next_line
| variable_with_scope {} // variables declaration
| variable_without_scope {} // variables declaration
| affectation {}
| printing {}
| IF expression DO statement_sequence ELSE statement_sequence ENDIF { printf("SI_SINON_ALORS \n"); }
| IF expression DO statement_sequence ENDIF { printf("SI   ALORS \n"); }
| WHEN NAME IS whenbody whendefault ENDWHEN {  printf("when .. case .. \n"); }
| WHILE expression DO  statement_sequence ENDWHILE { printf("WHILE .. DO .. \n"); }
| REPEAT statement_sequence UNTIL expression ENDREPEAT { printf("REPEAT .. UNTIL .. \n"); }
| for {}
;

affectation:
| NAME EGAL expression { cout << "Affectation " <<  endl; }
;

printing :
 PRINT string {cout <<"affichage : " << endl; } 
|PRINT string noms { printf("affichage \n"); } 
;

for :
  FOR NAME IN NUM_INTEGER POINT POINT nbrOrName STEP nbrOrName next_line DO  statement_sequence ENDFOR { printf("FOR .. IN ... \n");}
| FOR NAME IN NUM_INTEGER POINT POINT function_call STEP nbrOrName next_line DO  statement_sequence ENDFOR { printf("FOR .. IN ... \n");}
;

function_call : 
NAME POINT NAME LEFT_PARENTHESIS RIGHT_PARENTHESIS {}
;

nbrOrName:
  NUM_INTEGER  {}
| NUM_REAL
| designator {}
;

portee: 
 LOCAL {}
| GLOBAL {}
;

type:
  TYPE_INTEGER { }
| TYPE_REAL   { } 
| TYPE_STRING  { } 
| TYPE_BOOLEAN  { }
;

noms:
  COMMA NAME noms {}
| COMMA NAME {}
;

whenbody: /* whenbody can't be empty */
  whenbody CASE expression statement_sequence ENDCASE {}
| CASE expression statement_sequence ENDCASE {}
;

whendefault:
DEFAULT statement_sequence ENDCASE {}
;

string :
 STRING  {}

expression:
  expr2 {} 
| expr2 EGAL EGAL expr2 {  }
| expr2 NE expr2 { }
| expr2 LT expr2 {  }
| expr2 LE expr2 { }
| expr2 GT expr2 { }
| expr2 GE expr2 { }
;

expr2:
  expr3 {}
| expr2 PLUS expr3 {}
| expr2 MINUS expr3 { }
;

expr3:
  expr4 {}
| expr3 MULT expr4 { }
| expr3 DIVISE expr4 {  }
;

expr4:
  PLUS expr4 {}
| MINUS expr4 {}
| LEFT_PARENTHESIS expression RIGHT_PARENTHESIS {}
| NUM_REAL { } //real
| NUM_INTEGER {}  // integer
| designator {}
| function_call { }
;

designator:
  NAME { }
;

%%

void yyerror(const std::string& mess){
    std::cout << "Erreur trouvée a la ligne " << yylineno << " :  "<<mess  << std::endl;
}
